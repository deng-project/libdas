/*    ____         ________     __      _        ______  
 *   |  _ \_      |  ______|   |  \    | |     _/  ____\
 *   | | \_ \_    |  |         |   \   | |    /  _/   
 *   | |   \  |   |  |_____    | |\ \  | |   |  |   _____ 
 *   | |    | |   |  ______|   | | \ \ | |   |  |  |___  | 
 *   | |  _/ _|   |  |         | |  \ \| |    \  \    / /
 *   | |_/ _/     |  |_____    | |   \   |     \_ \__/ /
 *   |____/       |________|   |_|    \__|       \____/
 *               
 * __________________________________________________________
 * __________________________________________________________
 *                       Project DENG 
 *
 *
 * Copyright (C) 2020 - 2021
 * This Software is licensed under Apache License as described 
 * in the LICENSE.md file, which you should have recieved with 
 * this distribution.
 * 
 * You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 *     Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 *     stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 *     that You distribute, all copyright, patent, trademark, and
 *     attribution notices from the Source form of the Work,
 *     excluding those notices that do not pertain to any part of
 *     the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 *     distribution, then any Derivative Works that You distribute must
 *     include a readable copy of the attribution notices contained
 *     within such NOTICE file, excluding those notices that do not
 *     pertain to any part of the Derivative Works, in at least one
 *     of the following places: within a NOTICE text file distributed
 *     as part of the Derivative Works; within the Source form or
 *     documentation, if provided along with the Derivative Works; or,
 *     within a display generated by the Derivative Works, if and
 *     wherever such third-party notices normally appear. The contents
 *     of the NOTICE file are for informational purposes only and
 *     do not modify the License. You may add Your own attribution
 *     notices within Derivative Works that You distribute, alongside
 *     or as an addendum to the NOTICE text from the Work, provided
 *     that such additional attribution notices cannot be construed
 *     as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 */ 


#define __WAVEFRONT_OBJ_C
#include <data/wavefront_obj.h>


/// Read all file data from stream to heap allocated buffer
void __das_ReadToBuffer(char *file_name) {
    // Start reading the file
    FILE *file = fopen(file_name, "rb");
    if(!file) FILE_ERR(file_name);

    // Find the size of the file
    fseek(file, 0, SEEK_END);
    __buf_len = (deng_ui64_t) ftell(file);
    fseek(file, 0, SEEK_SET);

    // Allocate memory for char buffer
    __buffer = (char*) calloc(__buf_len + 1, sizeof(char));

    // Read from file to buffer
    size_t res = fread(__buffer, sizeof(char), __buf_len, file);

    // Check if the file reading was successful
    if(!res)
        FILE_ERR(file_name);

    // Allocate memory for storing all comment identifier instances
    size_t cid_cap = 64;
    size_t cid_c = 0;
    char **cids = calloc(cid_cap, sizeof(char*));

    // Find all comment identifiers
    char *cur = __buffer;
    char *next = NULL;
    while(cur < __buffer + __buf_len && (next = strchr(cur, '#'))) {
        // Check if reallocation of comment identifiers are needed
        __das_ReallocCheck((void**) &cids, &cid_cap, cid_c + 1, sizeof(char*), 
            "comment identifier array");

        cids[cid_c] = next;
        cur = next + 1;
        cid_c++;
    }

    // For each comment identifier uncomment until newline or eof
    for(size_t i = 0; i < cid_c; i++) {
        char *end = strchr(cids[i], 0x0A);
        end = !end ? __buffer + __buf_len : end;

        // Set the commented line as 0x20
        memset(cids[i], 0x20, end - cids[i]);
    }

    fclose(file);
}


/*
 * Free the allocated buffer used in data reading
 */
void __das_FreeBuffer() {
    free(__buffer);
    __buf_len = 0;
}


/*
 * Parse one line statement
 */
__das_WavefrontObjSpecType __das_ParseStatement(char **words, size_t word_c, deng_ui64_t line) {
    // If no words are present then return
    if(!word_c) 
        return DAS_WAVEFRONT_OBJ_SPEC_TYPE_NONE;

    // Find the keyword statement specifier
    __das_WavefrontObjStatement *statement = das_GetTokenInfo(words[0]);

    // Check if statement is valid and not NULL otherwise throw syntax error
    if(!statement) {
        char buf[__DAS_MAX_WORD_SIZE] = { 0 }; 
        sprintf(buf, "invalid keyword \"%s\"\n", words[0]);
        __DAS_WAVEFRONT_SYNTAX_ERROR(line, buf);
    }

    // Check if statement has enough arguments
    if((deng_i32_t) (word_c - 1) < statement->min_obj_c)
        __DAS_NOT_ENOUGH_ARGS(line);

    // Check if statement has too many arguments
    else if((deng_i32_t) (word_c - 1) > statement->max_obj_c)
        __DAS_TOO_MANY_ARGS(line);

    return statement->spec_type;
}


/*
 * Check if memory reallocations need to be done
 */
void __das_ReallocCheck (
    void **p_data, 
    size_t *p_cap, 
    size_t n,
    size_t size,
    char *err_msg
) {
    // Reallocate if the capacity is smaller than the required amount of elements
    if(n >= (*p_cap)) {
        size_t old_cap = (*p_cap);
        (*p_cap) = cm_ToPow2I64(n * 2);
        (*p_cap) = (*p_cap) < (old_cap << 1) ? old_cap << 1 : (*p_cap);
        void *tmp = realloc (
            (*p_data),
            (*p_cap) * size
        );

        if(!tmp) MEM_ERR(err_msg);
        
        (*p_data) = tmp;
    }
}


/*
 * Analyse the given line statement and perform action accordingly
 */
void __das_AnalyseStatement (
    char **line_words, 
    size_t word_c, 
    das_WavefrontObjEntity **p_entities, 
    size_t *p_ent_cap, 
    size_t *p_ent_c,
    deng_ui64_t lc
) { 
    // Parse the line statement
    __das_WavefrontObjSpecType obj_spec_type = __das_ParseStatement(line_words, word_c, lc);

    // Check for new action 
    switch(obj_spec_type) {
    case DAS_WAVEFRONT_OBJ_SPEC_TYPE_OBJ_DECL: {
        // Set a name variable if it exists
        char *name = NULL;
        if(word_c >= 2) 
            name = line_words[1];
        
        // Create a new object entity
        __das_NewEntity(p_entities, p_ent_cap, p_ent_c, DAS_ENTITY_TYPE_OBJECT, name);
        break;
    }

    case DAS_WAVEFRONT_OBJ_SPEC_TYPE_GROUP_DECL: {
        // Set a name variable if it exists
        char *name = NULL;
        if(word_c >= 2) 
            name = line_words[1];
        
        // Create a new group entity
        __das_NewEntity(p_entities, p_ent_cap, p_ent_c, DAS_ENTITY_TYPE_GROUP, name);
        break;
    }

    case DAS_WAVEFRONT_OBJ_SPEC_TYPE_VERT_DECL:
        // Check if vertex reallocation is needed
        __das_ReallocCheck((void**) &(*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.pos, 
            (void*) &(*p_entities)[(*p_ent_c) - 1].data.v_cap, (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.pn + 1, 
            sizeof(das_ObjPosData), "vertices array");
            
        // Set the entity vertices
        (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.pos[(*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.pn].vert_x = 
        (deng_vec_t) atof(line_words[1]);

        (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.pos[(*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.pn].vert_y = 
        (deng_vec_t) atof(line_words[2]);

        (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.pos[(*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.pn].vert_z = 
        (deng_vec_t) atof(line_words[3]);

        (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.pn++;
        break;

    case DAS_WAVEFRONT_OBJ_SPEC_TYPE_VERT_TEX_DECL:
        // Check if vertex reallocation is needed
        __das_ReallocCheck((void**) &(*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.tex, 
            (void*) &(*p_entities)[(*p_ent_c) - 1].data.vt_cap, (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.tn + 1,
            sizeof(das_ObjTextureData), "texture vertices array");
            
        // Set the entity texture vertices
        (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.tex[(*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.tn].tex_x = 
        (deng_vec_t) atof(line_words[1]);

        (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.tex[(*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.tn].tex_y = 
        (deng_vec_t) atof(line_words[2]);

        (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.tn++;
        break;

    case DAS_WAVEFRONT_OBJ_SPEC_TYPE_VERT_NORM_DECL:
        /*// Check if vertex normal reallocation is needed*/
        __das_ReallocCheck((void**) &(*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.norm, 
            (void*) &(*p_entities)[(*p_ent_c) - 1].data.vn_cap, (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.nn + 1,
            sizeof(das_ObjNormalData), "vertex normals array");
            
        // Set the entity vertex normals
        (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.norm[(*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.nn].nor_x = 
        (deng_vec_t) atof(line_words[1]);

        (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.norm[(*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.nn].nor_y = 
        (deng_vec_t) atof(line_words[2]);

        (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.norm[(*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.nn].nor_z = 
        (deng_vec_t) atof(line_words[3]);

        (*p_entities)[(*p_ent_c) - 1].data.vert_data.v3d.mul.nn++;
        break;

    case DAS_WAVEFRONT_OBJ_SPEC_TYPE_FACE_DECL:
        __das_CopyFaceIndices(((*p_entities) + (*p_ent_c) - 1), line_words, word_c);
        break;

    default:
        break;
    }
}


/*
 * Find all text blocks used between beg and beg + len
 */
void __das_ExtractBlocks (
    char *beg, 
    size_t len, 
    char ***p_words, 
    size_t *p_word_c, 
    size_t *p_word_cap,
    deng_ui64_t max_word_len
) {
    char *cur = beg;
    while(cur < beg + len) {
        // Skip all whitespaces, tabs and newlines
        while(cur < beg + len && (*cur == 0x20 || *cur == 0x09 || *cur == 0x0A || *cur == 0x0D))
            cur++;

        // Quit the loop if the maximum reading length is reached
        if(cur >= beg + len) break;
        
        // Check if block needs to be reallocated
        size_t old_cap = *p_word_cap;
        __das_ReallocCheck((void**) p_words, p_word_cap, (*p_word_c) + 1, sizeof(char*), 
            "wavefront statements");

        // For each allocated pointer location allocate memory for each character
        for(size_t i = old_cap; i < (*p_word_cap); i++)
            (*p_words)[i] = (char*) calloc(max_word_len, sizeof(char));

        // For each character until whitespace or newline set the block's value
        for(size_t i = 0; cur < beg + len && *cur != 0x20 && *cur != 0x09 && *cur != 0x0A && *cur != 0x0D; i++, cur++) {
            // Check if the block size is larger than allowed
            if(i >= max_word_len) {
                deng_ui64_t lc = cm_FindLineCount(__buffer, cur - __buffer);
                __DAS_TOO_LONG_WORD(lc);
            }
            (*p_words)[(*p_word_c)][i] = *cur;
        }
        
        (*p_word_c)++;
        cur++;
    }
}


/*
 * Create a new object or group instance for entity type
 */
void __das_NewEntity (
    das_WavefrontObjEntity **p_entities, 
    size_t *p_entity_cap, 
    size_t *p_entity_c,
    das_WavefrontObjEntityType ent_type,
    char *name
) {
    // Check if memory needs to be reallocated for entity array
    size_t old_cap = *p_entity_cap;
    __das_ReallocCheck((void**) p_entities, p_entity_cap, (*p_entity_c) + 1, sizeof(das_WavefrontObjEntity), 
        "statement entities");

    // If reallocation happened set the values of the newly allocated memory area to NULL
    for(size_t i = old_cap; i < (*p_entity_cap); i++)
        memset((void*) ((*p_entities) + i), 0, sizeof(das_WavefrontObjEntity));

    // Copy the name if available
    if(name) 
        strcpy((*p_entities)[*p_entity_c].data.name, name);

    (*p_entities)[(*p_entity_c)].type = ent_type;
    (*p_entity_c)++;

    // Allocate initial amount of memory for indices 
    (*p_entities)[(*p_entity_c) - 1].data.ind_cap = __DAS_DEFAULT_MEM_CAP;
    (*p_entities)[(*p_entity_c) - 1].data.ind_data.pos = (deng_ui32_t*) calloc(__DAS_DEFAULT_MEM_CAP, 
        sizeof(deng_ui32_t));

    (*p_entities)[(*p_entity_c) - 1].data.ind_data.tex = (deng_ui32_t*) calloc(__DAS_DEFAULT_MEM_CAP, 
        sizeof(deng_ui32_t));

    (*p_entities)[(*p_entity_c) - 1].data.ind_data.norm = (deng_ui32_t*) calloc(__DAS_DEFAULT_MEM_CAP, 
        sizeof(deng_ui32_t));


    // Allocate initial amount of memory for vertices 
    (*p_entities)[(*p_entity_c) - 1].data.v_cap = __DAS_DEFAULT_MEM_CAP;
    (*p_entities)[(*p_entity_c) - 1].data.vert_data.v3d.mul.pos = (das_ObjPosData*) calloc (
        __DAS_DEFAULT_MEM_CAP, sizeof(das_ObjPosData));

    (*p_entities)[(*p_entity_c) - 1].data.vt_cap = __DAS_DEFAULT_MEM_CAP;
    (*p_entities)[(*p_entity_c) - 1].data.vert_data.v3d.mul.tex = (das_ObjTextureData*) calloc (
        __DAS_DEFAULT_MEM_CAP, sizeof(das_ObjTextureData));

    (*p_entities)[(*p_entity_c) - 1].data.vn_cap = __DAS_DEFAULT_MEM_CAP;
    (*p_entities)[(*p_entity_c) - 1].data.vert_data.v3d.mul.norm = (das_ObjNormalData*) calloc (
        __DAS_DEFAULT_MEM_CAP, sizeof(das_ObjNormalData));
}

        
/*
 * Copy all face indices to entity structure
 */
void __das_CopyFaceIndices(das_WavefrontObjEntity *p_ent, char **words, size_t word_c) {
    // Check if indices need reallocation
    size_t cap = p_ent->data.ind_cap;
    __das_ReallocCheck((void**) &p_ent->data.ind_data.pos, 
        &cap, p_ent->data.ind_data.n + 1, sizeof(deng_ui32_t), 
        "position indices");

    cap = p_ent->data.ind_cap;
    __das_ReallocCheck((void**) &p_ent->data.ind_data.tex, 
        &cap, p_ent->data.ind_data.n + 1, sizeof(deng_ui32_t), 
        "texture indices");

    cap = p_ent->data.ind_cap;
    __das_ReallocCheck((void**) &p_ent->data.ind_data.norm, 
        &cap, p_ent->data.ind_data.n + 1, sizeof(deng_ui32_t), 
        "vertex normal indices");

    p_ent->data.ind_cap = cap;

    // For each face block parse it and save its data
    for(size_t i = 1; i < word_c; i++) {
        __das_IndexBlock block = __das_ParseFace(words[i]);
        
        // Check if parsed vertices index is UINT32_MAX
        p_ent->data.ind_data.n++;
        p_ent->data.ind_data.pos[p_ent->data.ind_data.n - 1] = block.pos - 1;
        p_ent->data.ind_data.tex[p_ent->data.ind_data.n - 1] = block.tex - 1;
        p_ent->data.ind_data.norm[p_ent->data.ind_data.n - 1] = block.norm - 1;
    }
}


/*
 * Parse a single face block
 */
__das_IndexBlock __das_ParseFace(char *face) {
    // UINT32_MAX basically means that this index is going to be ignored
    __das_IndexBlock ind_block = { UINT32_MAX };
    size_t face_len = strlen(face);
    
    // Separator and number buffer declaration
    char buf[32] = { 0 };
    char *sep[2] = { 0 };
    
    // Find all separators
    for(size_t i = 1, j = 0; i < face_len && j < 3; i++) {
        if(face[i] == '/') {
            sep[j] = face + i;
            j++;
        }
    }

    // Check if the first separator exists and if it does then copy value till separator
    if(sep[0]) {
        strncpy(buf, face, sep[0] - face);
        ind_block.pos = (deng_ui32_t) atoi(buf);
        memset(buf, 0, 32);
    }
    else {
        ind_block.pos = (deng_ui32_t) atoi(face);
        return ind_block;
    }
    
    // Check if the texture index exists
    char *end = !sep[1] ? face + face_len : sep[1];
    if(end - sep[0] > 1) {
        strncpy(buf, sep[0] + 1, end - sep[0]);
        ind_block.tex = (deng_ui32_t) atoi(buf);
        memset(buf, 0, 32);
    }

    // Check if second separator exists and has space between the third one
    end = face + face_len;
    if(sep[1] && end - sep[1] > 1) {
        strncpy(buf, sep[1] + 1, end - sep[1]);
        ind_block.norm = (deng_ui32_t) atoi(buf);
        memset(buf, 0, 32);
    }

    return ind_block;
} 


/*
 * Find the use specified object instance if needed
 */
size_t __das_PromptObjectIndex (
    size_t *obj_inds, 
    size_t obj_c, 
    das_WavefrontObjEntity *entities, 
    size_t ent_c,
    char *file_name
) {
    // Check if there are multiple objects to choose from
    size_t oid = 0;
    if(obj_c > 1) {
        printf("The file \'%s\' contains %ld object instances\n", file_name, obj_c);

        // For each object name in the array print out the name
        for(size_t i = 0; i < obj_c; i++) {
            if(entities[obj_inds[i]].data.name[0])
                printf("[%c] %s\n", 'a' + (char) i, entities[obj_inds[i]].data.name);
            else printf("[%c] ((unknown))\n", 'a' + (char) i);
        }

        printf("\nSelect the preferred object to use: \n> ");


        // Keep reading the input until input is correct
        while(1) {
            // Read the user input about the object to use
            char ch = 0;
            int res = scanf("%c", &ch);
            if(!res) RUN_ERR("__das_PromptObjectIndex()", "Failed to read user input from stdin");
            oid = ch - 'a';

            // Check if the specified character is not out of bounds
            if(oid < obj_c) break;

            printf("Unspecified identifier '%c'\n", ch);
        }
    }

    return obj_inds[oid];
}


/*
 * Temporary function for printing out all entity data
 */
void __das_PrintEntityData(das_WavefrontObjEntity *entities, size_t ent_c) {
    // For each entity print out its contents
    for(size_t i = 0; i < ent_c; i++) {
        printf("o %s\n", entities[i].data.name);

        // Print all position vertices data
        for(size_t j = 0; j < entities[i].data.vert_data.v3d.mul.pn; j++) {
            printf("v %f %f %f\n", entities[i].data.vert_data.v3d.mul.pos[j].vert_x,
                entities[i].data.vert_data.v3d.mul.pos[j].vert_y, entities[i].data.vert_data.v3d.mul.pos[j].vert_z);
        }

        // Print all texture vertices data
        for(size_t j = 0; j < entities[i].data.vert_data.v3d.mul.tn; j++) {
            printf("vt %f %f\n", entities[i].data.vert_data.v3d.mul.tex[j].tex_x,
                entities[i].data.vert_data.v3d.mul.tex[j].tex_y);
        }

        // Print all vertex normals data
        for(size_t j = 0; j < entities[i].data.vert_data.v3d.mul.nn; j++) {
            printf("vn %f %f %f\n", entities[i].data.vert_data.v3d.mul.norm[j].nor_x,
                entities[i].data.vert_data.v3d.mul.norm[j].nor_y, entities[i].data.vert_data.v3d.mul.norm[j].nor_z);
        }

        // Print all indices
        for(size_t j = 0; j < entities[i].data.ind_data.n; j++) {
            printf("f %d/%d/%d\n", entities[i].data.ind_data.pos[j], entities[i].data.ind_data.tex[j],
                entities[i].data.ind_data.norm[j]);
        }
    }
}


/// Parse all data in Wavefront OBJ file and write
/// all information about vertices and indices to p_asset
void das_ParseWavefrontOBJ (
    das_WavefrontObjEntity **p_ents, 
    size_t *p_ent_c, 
    char *file_name
) {
    das_WavefrontObjTokenise();
    __das_ReadToBuffer(file_name);
    size_t entity_cap = 8;
    *p_ent_c = 0;
    (*p_ents) = (das_WavefrontObjEntity*) calloc(entity_cap, sizeof(das_WavefrontObjEntity));

    // Set up the initial global entity
    __das_NewEntity(p_ents, &entity_cap, p_ent_c, DAS_ENTITY_TYPE_OBJECT, "Default");

    // Allocate memory for line words
    size_t word_cap = 8;
    size_t word_c = 0;

    // Allocate memory for line words
    char **line_words = (char**) calloc(word_cap, sizeof(char*));
    for(size_t i = 0; i < word_cap; i++) 
        line_words[i] = (char*) calloc(__DAS_MAX_WORD_SIZE, sizeof(char));

    // Read the buffer line by line
    char *cur = __buffer;
    char *end = NULL;
    deng_ui64_t lc = 1;
    while(cur < __buffer + __buf_len) {
        // Find the newline and if it does not exist set the end as eof
        end = strchr(cur, 0x0a);
        end = !end ? __buffer + __buf_len : end;

        // Find all the statements in the line
        __das_ExtractBlocks(cur, end - cur, &line_words, &word_c, &word_cap, __DAS_MAX_WORD_SIZE);
        
        // If no blocks were found skip the iteration
        if(!word_c) {
            lc++;
            cur = end + 1;
            continue;
        }

        // Analyse the retrieved line
        __das_AnalyseStatement(line_words, word_c, p_ents, 
            &entity_cap, p_ent_c, lc);

        cur = end + 1;

        // Reset all the words that were read
        for(size_t i = 0; i < word_c; i++)
            memset(line_words[i], 0, __DAS_MAX_WORD_SIZE * sizeof(char));
        
        lc++;
        word_c = 0;
    }

    // Clear all memory that was allocated for tokens
    das_WavefrontObjUntokenise();

    // Clean all the memory that was for line words
    for(size_t i = 0; i < word_cap; i++)
        free(line_words[i]);
    free(line_words);

    __das_FreeBuffer();
}


/// Write entity data to a asset and if needed prompt to ask for the correct group
/// that will be used in the asset
void das_WavefrontObjEntityWritePrompt (
    das_Asset *p_asset, 
    das_WavefrontObjEntity *entities, 
    size_t ent_c,
    char *file_name
) {
    printf("Checking for groups and objects\n");
    
    // Allocate memory for each type
    size_t obj_c = 0;
    size_t *obj_inds = (size_t*) calloc(ent_c, sizeof(size_t));

    // Check for each entity type
    for(size_t i = 0; i < ent_c; i++) {
        // If the type is object then add it to the object array
        if(entities[i].type == DAS_ENTITY_TYPE_OBJECT) {
            // Check if the object is not a global object and that it has vertices
            if(entities[i].data.name[0] && entities[i].data.vert_data.v3d.mul.pn) {
                obj_inds[obj_c] = i;
                obj_c++;
            }
        }
    }


    // Find the object index
    size_t oid = __das_PromptObjectIndex(obj_inds, obj_c, entities, ent_c, file_name);

    // Allocate initial amount of memory for vertices 
    size_t pcap = cm_ToPow2I64(entities[oid].data.vert_data.v3d.mul.pn + 128);
    size_t tcap = cm_ToPow2I64(entities[oid].data.vert_data.v3d.mul.tn + 128);
    size_t ncap = cm_ToPow2I64(entities[oid].data.vert_data.v3d.mul.nn + 128);

    p_asset->uuid = uuid_Generate();
    p_asset->asset_mode = DAS_ASSET_MODE_3D_TEXTURE_MAPPED;
    p_asset->vertices.v3d.mul.pn = 0;
    p_asset->vertices.v3d.mul.tn = 0;
    p_asset->vertices.v3d.mul.nn = 0;

    p_asset->vertices.v3d.mul.pos = (das_ObjPosData*) calloc(pcap, sizeof(das_ObjPosData));
    p_asset->vertices.v3d.mul.tex = (das_ObjTextureData*) calloc(tcap, sizeof(das_ObjTextureData));
    p_asset->vertices.v3d.mul.norm = (das_ObjNormalData*) calloc(ncap, sizeof(das_ObjNormalData));

    // Allocate initial amount of memory for indices 
    size_t ind_cap = cm_ToPow2I64(entities[oid].data.ind_data.n + 128);

    p_asset->indices.n = 0;
    p_asset->indices.pos = (deng_ui32_t*) calloc(ind_cap, sizeof(deng_ui32_t));
    p_asset->indices.tex = (deng_ui32_t*) calloc(ind_cap, sizeof(deng_ui32_t));
    p_asset->indices.norm = (deng_ui32_t*) calloc(ind_cap, sizeof(deng_ui32_t));

    // For each entity starting from the current object id copy the indices and vertices to asset
    deng_bool_t read_next_obj = false;
    for(size_t i = oid; i < ent_c; i++) {
        // If the type is object and index is not the oid then quit the loop
        if(!read_next_obj && i != oid && entities[i].data.ind_data.n && entities[i].type == DAS_ENTITY_TYPE_OBJECT) 
            break;
        else if(read_next_obj) read_next_obj = false;

        // Check if vertices data can be read
        if(entities[i].data.vert_data.v3d.mul.pn) {
            // Check if any additional memory is needed for vertices
            __das_ReallocCheck((void**) &p_asset->vertices.v3d.mul.pos, &pcap, p_asset->vertices.v3d.mul.pn + 
                entities[i].data.vert_data.v3d.mul.pn, sizeof(das_ObjPosData), "position vertices");
            __das_ReallocCheck((void**) &p_asset->vertices.v3d.mul.tex, &tcap, p_asset->vertices.v3d.mul.tn +
                entities[i].data.vert_data.v3d.mul.tn, sizeof(das_ObjTextureData), "texture vertices");
            __das_ReallocCheck((void**) &p_asset->vertices.v3d.mul.norm, &ncap, p_asset->vertices.v3d.mul.nn +
                entities[i].data.vert_data.v3d.mul.nn, sizeof(das_ObjNormalData), "vertex normals");

            // Copy all vertices to the asset
            memcpy(p_asset->vertices.v3d.mul.pos + p_asset->vertices.v3d.mul.pn, entities[i].data.vert_data.v3d.mul.pos, 
                entities[i].data.vert_data.v3d.mul.pn * sizeof(das_ObjPosData));
            memcpy(p_asset->vertices.v3d.mul.tex + p_asset->vertices.v3d.mul.tn, entities[i].data.vert_data.v3d.mul.tex, 
                entities[i].data.vert_data.v3d.mul.tn * sizeof(das_ObjTextureData));
            memcpy(p_asset->vertices.v3d.mul.norm + p_asset->vertices.v3d.mul.nn, entities[i].data.vert_data.v3d.mul.norm, 
                entities[i].data.vert_data.v3d.mul.nn * sizeof(das_ObjNormalData));
        } else read_next_obj = true;

        if(entities[i].data.ind_data.n) {
            // Check if any additional memory is needed for indices
            size_t old_cap = ind_cap;
            __das_ReallocCheck((void**) &p_asset->indices.pos, &ind_cap, p_asset->indices.n +  
                entities[i].data.ind_data.n, sizeof(deng_ui32_t), "position indices");
            ind_cap = old_cap;
            __das_ReallocCheck((void**) &p_asset->indices.tex, &ind_cap, p_asset->indices.n +  
                entities[i].data.ind_data.n, sizeof(deng_ui32_t), "texture indices");
            ind_cap = old_cap;
            __das_ReallocCheck((void**) &p_asset->indices.norm, &ind_cap, p_asset->indices.n +  
                entities[i].data.ind_data.n, sizeof(deng_ui32_t), "vertex normal indices");

            // Copy all indices to the asset
            memcpy(p_asset->indices.pos + p_asset->indices.n, entities[i].data.ind_data.pos, 
                entities[i].data.ind_data.n * sizeof(deng_ui32_t));
            memcpy(p_asset->indices.tex + p_asset->indices.n, entities[i].data.ind_data.tex, 
                entities[i].data.ind_data.n * sizeof(deng_ui32_t));
            memcpy(p_asset->indices.norm + p_asset->indices.n, entities[i].data.ind_data.norm, 
                entities[i].data.ind_data.n * sizeof(deng_ui32_t));

            p_asset->vertices.v3d.mul.pn += entities[i].data.vert_data.v3d.mul.pn;
            p_asset->vertices.v3d.mul.tn += entities[i].data.vert_data.v3d.mul.tn;
            p_asset->vertices.v3d.mul.nn += entities[i].data.vert_data.v3d.mul.nn;

            p_asset->indices.n += entities[i].data.ind_data.n;
        } else read_next_obj = true;
    }
}


/// Perform cleanup operation for all the memory allocated for entities
void das_WavefrontObjDestroyEntities(das_WavefrontObjEntity *entities, size_t ent_c) {
    // For each entity free its vertices and indices
    for(size_t i = 0; i < ent_c; i++) {
        free(entities[i].data.vert_data.v3d.mul.pos);
        free(entities[i].data.vert_data.v3d.mul.tex);
        free(entities[i].data.vert_data.v3d.mul.norm);

        free(entities[i].data.ind_data.pos);
        free(entities[i].data.ind_data.tex);
        free(entities[i].data.ind_data.norm);
    }

    free(entities);
}
